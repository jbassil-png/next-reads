<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Next Reads</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; margin: 24px; max-width: 1050px; }
    h1 { margin: 0 0 6px; }
    p { margin: 0 0 18px; color: #444; }
    .grid { display: grid; grid-template-columns: 1fr; gap: 14px; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 14px; }
    .card h2 { margin: 0 0 10px; font-size: 16px; }
    .row { display: grid; grid-template-columns: 1fr 1fr auto; gap: 10px; align-items: end; }
    label { display: grid; gap: 6px; font-size: 13px; color: #333; }
    input { padding: 9px 10px; border-radius: 10px; border: 1px solid #ccc; }
    button { padding: 9px 12px; border-radius: 10px; border: 1px solid #ccc; background: #f7f7f7; cursor: pointer; }
    button.primary { background: #111; color: #fff; border-color: #111; }
    button:disabled { opacity: 0.6; cursor: not-allowed; }
    .muted { color: #666; font-size: 13px; }
    table { width: 100%; border-collapse: collapse; }
    th, td { border-bottom: 1px solid #eee; text-align: left; padding: 8px 6px; font-size: 14px; vertical-align: top; }
    th { color: #555; font-weight: 600; }
    .results { display: grid; gap: 10px; }
    .result { border: 1px solid #eee; border-radius: 10px; padding: 10px; display: grid; gap: 6px; }
    .result-title { font-weight: 650; }
    .actions { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 10px; }
    textarea { width: 100%; min-height: 180px; padding: 10px; border-radius: 10px; border: 1px solid #ccc;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; }
    hr { border: none; border-top: 1px solid #eee; margin: 12px 0; }
    a { color: #444; }
  </style>
</head>
<body>

  <h1>Next Reads</h1>
  <p>A personal dashboard for upcoming book releases. Add by title+author → validate → add.</p>

  <div class="grid">
    <section class="card">
      <h2>Add a book</h2>

      <!-- NOTE: We intentionally do NOT submit this form. Validate is a plain button. -->
      <form id="validate-form" class="row" autocomplete="off">
        <label>
          Title
          <input id="title" type="text" required>
        </label>

        <label>
          Author
          <input id="author" type="text" required>
        </label>

        <button id="validate-btn" type="button" class="primary">Validate</button>
      </form>

      <div id="selected" class="muted" style="margin-top:10px;"></div>

      <div class="actions">
        <button id="add-btn" type="button" class="primary" disabled>Add to list</button>
        <button id="clear-selection" type="button">Clear selection</button>
      </div>

      <hr>

      <div class="muted">
        Validation uses Google Books. If only a year/month is available, we store a sortable date and a precision flag.
      </div>

      <div id="results" class="results" style="margin-top:12px;"></div>
    </section>

    <section class="card">
      <h2>Dashboard</h2>
      <div id="app" class="muted">Loading…</div>
    </section>

    <section class="card">
      <h2>Save changes to GitHub</h2>
      <div class="muted">
        This app can’t directly edit <code>books.json</code> yet, so new books are saved in your browser as a “Draft”.
        When ready, generate an updated <code>books.json</code>, paste it into GitHub, and commit.
      </div>

      <div class="actions">
        <button id="generate-json" type="button">Generate updated books.json</button>
        <button id="copy-json" type="button">Copy output</button>
        <button id="clear-draft" type="button">Clear local Draft</button>
      </div>

      <textarea id="output" placeholder="Click “Generate updated books.json”…"></textarea>
    </section>
  </div>

  <script>
    const DRAFT_KEY = "next_reads_draft_v1";

    function loadDraft() {
      const raw = localStorage.getItem(DRAFT_KEY);
      if (!raw) return [];
      try { return JSON.parse(raw); } catch { return []; }
    }

    function saveDraft(draft) {
      localStorage.setItem(DRAFT_KEY, JSON.stringify(draft));
    }

    async function loadBooksJson() {
      const response = await fetch("books.json", { cache: "no-store" });
      return await response.json();
    }

    // Date precision handling (agreed defaults):
    // YYYY       -> YYYY-12-31, precision "year"
    // YYYY-MM    -> YYYY-MM-01, precision "month"
    // YYYY-MM-DD -> exact, precision "day"
    function normalizePublishedDate(publishedDate) {
      if (!publishedDate || typeof publishedDate !== "string") return null;

      if (/^\d{4}$/.test(publishedDate)) {
        return { release_date: `${publishedDate}-12-31`, precision: "year", raw: publishedDate };
      }
      if (/^\d{4}-\d{2}$/.test(publishedDate)) {
        return { release_date: `${publishedDate}-01`, precision: "month", raw: publishedDate };
      }
      if (/^\d{4}-\d{2}-\d{2}$/.test(publishedDate)) {
        return { release_date: publishedDate, precision: "day", raw: publishedDate };
      }
      return null;
    }

    function parseISODate(dateStr) {
      const [y, m, d] = dateStr.split("-").map(Number);
      return new Date(Date.UTC(y, m - 1, d));
    }

    function daysBetweenUTC(a, b) {
      const msPerDay = 24 * 60 * 60 * 1000;
      const aUTC = Date.UTC(a.getUTCFullYear(), a.getUTCMonth(), a.getUTCDate());
      const bUTC = Date.UTC(b.getUTCFullYear(), b.getUTCMonth(), b.getUTCDate());
      return Math.round((bUTC - aUTC) / msPerDay);
    }

    // --- Reminder logic (4.3) ---
const REMINDER_SCHEDULE = [
  { key: "30d", days: 30 },
  { key: "14d", days: 14 },
  { key: "7d",  days: 7 },
  { key: "1d",  days: 1 },
  { key: "release_day", days: 0 }
];

function getDaysUntilRelease(book, today) {
  if (!book || !book.release_date) return null;
  const release = parseISODate(book.release_date);
  return daysBetweenUTC(today, release); // positive = future
}

function getReminderDueTodayKey(book, today) {
  // Returns a key like "14d" if a reminder is due today and not yet sent, else null.
  if (!book?.notifications?.on_release) return null;
  if (!book.reminder_flags) return null;

  const delta = getDaysUntilRelease(book, today);
  if (delta === null) return null;
  if (delta < 0) return null; // past release

  for (const r of REMINDER_SCHEDULE) {
    if (delta === r.days && book.reminder_flags[r.key] === false) {
      return r.key;
    }
  }
  return null;
}

function getNextReminder(book, today) {
  // Returns { key, days, inDays } for the next unsent reminder in the future, else null.
  if (!book?.notifications?.on_release) return null;
  if (!book.reminder_flags) return null;

  const delta = getDaysUntilRelease(book, today);
  if (delta === null) return null;
  if (delta < 0) return null;

  // Example: delta=45 -> next reminder is 30d (in 15 days)
  const candidates = REMINDER_SCHEDULE
    .filter(r => r.days <= delta && book.reminder_flags[r.key] === false)
    .sort((a, b) => b.days - a.days);

  if (!candidates.length) return null;

  const next = candidates[0];
  return { ...next, inDays: delta - next.days };
}


    function pickIsbn13(industryIdentifiers) {
      if (!Array.isArray(industryIdentifiers)) return null;
      const isbn13 = industryIdentifiers.find(x => x && x.type === "ISBN_13" && x.identifier);
      return isbn13 ? isbn13.identifier : null;
    }

    function escapeHtml(s) {
      return String(s)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }
function renderDashboard(books) {
  const app = document.getElementById("app");
  const today = new Date();
  const SOON_DAYS = 30;

  const published = [];
  const comingSoon = [];
  const comingLater = [];

  for (const b of books) {
    if (!b || !b.release_date) continue;

    const delta = getDaysUntilRelease(b, today);
    if (delta === null) continue;

    if (delta < 0) published.push(b);
    else if (delta <= SOON_DAYS) comingSoon.push(b);
    else comingLater.push(b);
  }

  // Sorting
  published.sort((a, b) => b.release_date.localeCompare(a.release_date));     // most recent first
  comingSoon.sort((a, b) => a.release_date.localeCompare(b.release_date));   // soonest first
  comingLater.sort((a, b) => a.release_date.localeCompare(b.release_date));  // soonest first

  function libraryLabel(b) {
    if (!b.library || b.library.status === "unknown") return "Unknown";
    if (b.library.status === "not_found") return "Not found";
    if (b.library.status === "found") return "Found";
    return "Unknown";
  }

  function reminderLabel(b) {
    const dueKey = getReminderDueTodayKey(b, today);
    if (dueKey) return { text: `Due today: ${dueKey}`, dueKey };

    const next = getNextReminder(b, today);
    if (!next) return { text: "—", dueKey: null };

    if (next.inDays === 0) return { text: `Due today: ${next.key}`, dueKey: next.key };
    return { text: `Next: ${next.key} (in ${next.inDays}d)`, dueKey: null };
  }

  function sectionHtml(title, subtitle, rows, mode) {
    // mode: "published" | "soon" | "later" (just for the Days label)
    const subtitleHtml = subtitle
      ? `<div class="muted" style="margin:-2px 0 10px;">${subtitle}</div>`
      : "";

    if (!rows.length) {
      return `
        <div style="margin-top:10px;">
          <h3 style="margin:10px 0 4px; font-size:14px;">${title} (0)</h3>
          ${subtitleHtml}
          <div class="muted">None.</div>
        </div>`;
    }

    const rowsHtml = rows.map((book, idx) => {
      const delta = getDaysUntilRelease(book, today);
      const daysLabel =
        mode === "published" ? `+${Math.abs(delta)}d` : `in ${delta}d`;

      const precision = book.release_date_precision ? ` (${escapeHtml(book.release_date_precision)})` : "";
      const lib = libraryLabel(book);

      const canEdit = book.source === "google_books"; // Draft-only edits
      const r = reminderLabel(book);

      return `
        <tr data-idx="${idx}">
          <td>${escapeHtml(book.title || "")}</td>
          <td>${escapeHtml(book.author || "")}</td>
          <td>${escapeHtml(book.release_date)}${precision}</td>
          <td>${daysLabel}</td>
          <td>${lib}</td>
          <td>${escapeHtml(r.text)}</td>
          <td>
            ${canEdit ? `
              <button data-action="found">Found</button>
              <button data-action="not_found">Not found</button>
              ${r.dueKey ? `<button data-action="mark_sent" data-reminder="${escapeHtml(r.dueKey)}">Mark sent</button>` : ``}
            ` : `<span class="muted">—</span>`}
          </td>
        </tr>`;
    }).join("");

    return `
      <div style="margin-top:10px;">
        <h3 style="margin:10px 0 4px; font-size:14px;">${title} (${rows.length})</h3>
        ${subtitleHtml}
        <table>
          <thead>
            <tr>
              <th>Title</th>
              <th>Author</th>
              <th>Release</th>
              <th>Days</th>
              <th>Library</th>
              <th>Reminders</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody>${rowsHtml}</tbody>
        </table>
      </div>`;
  }

  // Always render all three sections (even if empty)
  app.innerHTML =
    sectionHtml(
      "Published",
      "Already released. Track library availability / holds here.",
      published,
      "published"
    ) +
    sectionHtml(
      "Coming Soon",
      `Publishing within the next ${SOON_DAYS} days.`,
      comingSoon,
      "soon"
    ) +
    sectionHtml(
      "Coming Later",
      `Publishing more than ${SOON_DAYS} days from now.`,
      comingLater,
      "later"
    );

  // Wire up buttons (Draft books only)
  app.querySelectorAll("button[data-action]").forEach(btn => {
    btn.addEventListener("click", () => {
      const tr = btn.closest("tr");
      const idx = Number(tr.dataset.idx);
      const action = btn.dataset.action;

      // IMPORTANT: idx is per-section, but we rendered each section independently.
      // To keep this simple and reliable, we’ll recompute a single flat list mapping:
      // We'll locate the matching book row by its title+author+release_date from DOM.
      const tds = tr.querySelectorAll("td");
      const rowTitle = tds[0]?.textContent || "";
      const rowAuthor = tds[1]?.textContent || "";
      const rowRelease = tds[2]?.textContent?.slice(0, 10) || ""; // "YYYY-MM-DD" portion

      const book = books.find(b =>
        (b.title || "") === rowTitle &&
        (b.author || "") === rowAuthor &&
        (b.release_date || "") === rowRelease
      );
      if (!book) return;

      if (action === "found" || action === "not_found") {
        if (!book.library) book.library = { status: "unknown", checked_at: null };
        book.library.status = action === "found" ? "found" : "not_found";
        book.library.checked_at = new Date().toISOString();
      }

      if (action === "mark_sent") {
        const key = btn.dataset.reminder;
        if (book.reminder_flags && key && Object.prototype.hasOwnProperty.call(book.reminder_flags, key)) {
          book.reminder_flags[key] = true;
        }
      }

      const draft = loadDraft();
      const updatedDraft = draft.map(d =>
        d.title === book.title && d.author === book.author ? book : d
      );

      saveDraft(updatedDraft);
      renderDashboard(books);
    });
  });
}


  upcoming.sort((a, b) => a.release_date.localeCompare(b.release_date));
  waiting.sort((a, b) => b.release_date.localeCompare(a.release_date));

  function libraryLabel(b) {
    if (!b.library || b.library.status === "unknown") return "Unknown";
    if (b.library.status === "not_found") return "Not found";
    if (b.library.status === "found") return "Found";
    return "Unknown";
  }

  function reminderLabel(b) {
    const dueKey = getReminderDueTodayKey(b, today);
    if (dueKey) return { text: `Due today: ${dueKey}`, dueKey };

    const next = getNextReminder(b, today);
    if (!next) return { text: "—", dueKey: null };

    if (next.inDays === 0) return { text: `Due today: ${next.key}`, dueKey: next.key };
    return { text: `Next: ${next.key} (in ${next.inDays}d)`, dueKey: null };
  }

  function sectionHtml(title, rows, mode) {
    if (!rows.length) {
      return `
        <div style="margin-top:10px;">
          <h3 style="margin:10px 0 8px; font-size:14px;">${title} (0)</h3>
          <div class="muted">None.</div>
        </div>`;
    }

    const rowsHtml = rows.map((book, idx) => {
      const delta = getDaysUntilRelease(book, today);
      const daysLabel = mode === "upcoming" ? `in ${delta}d` : `+${Math.abs(delta)}d`;
      const precision = book.release_date_precision ? ` (${escapeHtml(book.release_date_precision)})` : "";
      const lib = libraryLabel(book);

      const canEdit = book.source === "google_books"; // Draft-only edits
      const r = reminderLabel(book);

      return `
        <tr data-idx="${idx}">
          <td>${escapeHtml(book.title || "")}</td>
          <td>${escapeHtml(book.author || "")}</td>
          <td>${escapeHtml(book.release_date)}${precision}</td>
          <td>${daysLabel}</td>
          <td>${lib}</td>
          <td>${escapeHtml(r.text)}</td>
          <td>
            ${canEdit ? `
              <button data-action="found">Found</button>
              <button data-action="not_found">Not found</button>
              ${r.dueKey ? `<button data-action="mark_sent" data-reminder="${escapeHtml(r.dueKey)}">Mark sent</button>` : ``}
            ` : `<span class="muted">—</span>`}
          </td>
        </tr>`;
    }).join("");

    return `
      <div style="margin-top:10px;">
        <h3 style="margin:10px 0 8px; font-size:14px;">${title} (${rows.length})</h3>
        <table>
          <thead>
            <tr>
              <th>Title</th>
              <th>Author</th>
              <th>Release</th>
              <th>Days</th>
              <th>Library</th>
              <th>Reminders</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody>${rowsHtml}</tbody>
        </table>
      </div>`;
  }

  app.innerHTML =
    sectionHtml("Upcoming", upcoming, "upcoming") +
    sectionHtml("Released (waiting for library)", waiting, "waiting");

  // Wire up buttons (Draft books only)
  app.querySelectorAll("button[data-action]").forEach(btn => {
    btn.addEventListener("click", () => {
      const tr = btn.closest("tr");
      const idx = Number(tr.dataset.idx);
      const action = btn.dataset.action;
      const book = books[idx];
      if (!book) return;

      if (action === "found" || action === "not_found") {
        if (!book.library) book.library = { status: "unknown", checked_at: null };
        book.library.status = action === "found" ? "found" : "not_found";
        book.library.checked_at = new Date().toISOString();
      }

      if (action === "mark_sent") {
        const key = btn.dataset.reminder;
        if (book.reminder_flags && key && Object.prototype.hasOwnProperty.call(book.reminder_flags, key)) {
          book.reminder_flags[key] = true;
        }
      }

      // Persist Draft changes only
      const draft = loadDraft();
      const updatedDraft = draft.map(d =>
        d.title === book.title && d.author === book.author ? book : d
      );

      saveDraft(updatedDraft);
      renderDashboard(books);
    });
  });
}

  upcoming.sort((a, b) => a.release_date.localeCompare(b.release_date));
  waiting.sort((a, b) => b.release_date.localeCompare(a.release_date));

  function libraryLabel(b) {
    if (!b.library || b.library.status === "unknown") return "Unknown";
    if (b.library.status === "not_found") return "Not found";
    if (b.library.status === "found") return "Found";
    return "Unknown";
  }

  function sectionHtml(title, rows, mode) {
    if (!rows.length) {
      return `<div style="margin-top:10px;">
        <h3 style="margin:10px 0 8px; font-size:14px;">${title} (0)</h3>
        <div class="muted">None.</div>
      </div>`;
    }

    const rowsHtml = rows.map((book, idx) => {
      const release = parseISODate(book.release_date);
      const delta = daysBetweenUTC(today, release);
      const daysLabel = mode === "upcoming" ? `in ${delta}d` : `+${Math.abs(delta)}d`;
      const precision = book.release_date_precision ? ` (${escapeHtml(book.release_date_precision)})` : "";
      const lib = libraryLabel(book);
      const canEdit = book.source === "google_books"; // Draft only

      return `
        <tr data-idx="${idx}">
          <td>${escapeHtml(book.title || "")}</td>
          <td>${escapeHtml(book.author || "")}</td>
          <td>${escapeHtml(book.release_date)}${precision}</td>
          <td>${daysLabel}</td>
          <td>${lib}</td>
          <td>
            ${canEdit ? `
              <button data-action="found">Found</button>
              <button data-action="not_found">Not found</button>
            ` : `<span class="muted">—</span>`}
          </td>
        </tr>`;
    }).join("");

    return `<div style="margin-top:10px;">
      <h3 style="margin:10px 0 8px; font-size:14px;">${title} (${rows.length})</h3>
      <table>
        <thead>
          <tr>
            <th>Title</th>
            <th>Author</th>
            <th>Release</th>
            <th>Days</th>
            <th>Library</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody>${rowsHtml}</tbody>
      </table>
    </div>`;
  }

  app.innerHTML =
    sectionHtml("Upcoming", upcoming, "upcoming") +
    sectionHtml("Released (waiting for library)", waiting, "waiting");

  // Wire up buttons
  app.querySelectorAll("button[data-action]").forEach(btn => {
    btn.addEventListener("click", () => {
      const tr = btn.closest("tr");
      const idx = Number(tr.dataset.idx);
      const action = btn.dataset.action;
      const book = books[idx];

      if (!book.library) {
        book.library = { status: "unknown", checked_at: null };
      }

      book.library.status = action === "found" ? "found" : "not_found";
      book.library.checked_at = new Date().toISOString();

      // Persist Draft changes only
      const draft = loadDraft();
      const updatedDraft = draft.map(d =>
        d.title === book.title && d.author === book.author ? book : d
      );

      saveDraft(updatedDraft);
      renderDashboard(books);
    });
  });
}


    async function searchGoogleBooks(title, author) {
      const q = `intitle:${title} inauthor:${author}`;
      const url = `https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(q)}&maxResults=5`;
      const resp = await fetch(url);

      // Helpful error detail (shown in console)
      if (!resp.ok) {
        const txt = await resp.text().catch(() => "");
        throw new Error(`Google Books request failed: ${resp.status} ${resp.statusText} ${txt}`);
      }

      return await resp.json();
    }

    async function copyToClipboard(text) {
      await navigator.clipboard.writeText(text);
    }

    (async function init() {
      let draft = loadDraft();
      let selectedBook = null;

      const resultsEl = document.getElementById("results");
      const selectedEl = document.getElementById("selected");
      const addBtn = document.getElementById("add-btn");
      const outputEl = document.getElementById("output");

      async function refreshDashboard() {
        const current = await loadBooksJson();
        const repoBooks = Array.isArray(current.books) ? current.books : [];
        const merged = [...draft, ...repoBooks];
        renderDashboard(merged);
      }

      function clearSelection() {
        selectedBook = null;
        selectedEl.textContent = "";
        addBtn.disabled = true;
      }

      function renderResults(items) {
        resultsEl.innerHTML = "";

        if (!items.length) {
          resultsEl.innerHTML = `<div class="muted">No matches found. Try adjusting title/author.</div>`;
          return;
        }

        for (const item of items) {
          const info = item.volumeInfo || {};
          const title = info.title || "(no title)";
          const authors = Array.isArray(info.authors) ? info.authors.join(", ") : "(no authors)";
          const publishedDate = info.publishedDate || "(no date)";
          const norm = normalizePublishedDate(info.publishedDate);
          const isbn13 = pickIsbn13(info.industryIdentifiers);
          const link = info.infoLink || "";

          const card = document.createElement("div");
          card.className = "result";
          card.innerHTML = `
            <div class="result-title">${escapeHtml(title)}</div>
            <div class="muted">${escapeHtml(authors)}</div>
            <div class="muted">Published: ${escapeHtml(publishedDate)}${norm ? ` → Using: ${escapeHtml(norm.release_date)} (${escapeHtml(norm.precision)})` : ""}</div>
            <div class="muted">${isbn13 ? `ISBN-13: ${escapeHtml(isbn13)}` : ""}</div>
            <div class="actions">
              <button type="button" data-use="1" ${norm ? "" : "disabled"}>Use</button>
              ${link ? `<a class="muted" href="${escapeHtml(link)}" target="_blank" rel="noreferrer">View</a>` : ""}
            </div>
          `;

          const useBtn = card.querySelector('button[data-use="1"]');
          if (useBtn) {
            useBtn.addEventListener("click", () => {
              if (!norm) return;

selectedBook = {
  title,
  author: (authors.split(",")[0] || authors).trim(),
  release_date: norm.release_date,
  release_date_precision: norm.precision,
  release_date_raw: norm.raw,
  status: "upcoming",
  source: "google_books",

  library: {
    status: "unknown",       // unknown | not_found | found
    checked_at: null
  },

  notifications: {
    on_release: true,
    on_library: true
  },

  reminder_flags: {
    "30d": false,
    "14d": false,
    "7d": false,
    "1d": false,
    "release_day": false
  },

  ...(isbn13 ? { isbn: isbn13 } : {}),
  ...(link ? { link } : {})
};


              selectedEl.textContent =
                `Selected: ${selectedBook.title} — ${selectedBook.author} — ${selectedBook.release_date} (${selectedBook.release_date_precision})`;

              addBtn.disabled = false;
            });
          }

          resultsEl.appendChild(card);
        }
      }

      // Initial dashboard render
      await refreshDashboard();

      // Validate button click (no form submit)
      document.getElementById("validate-btn").addEventListener("click", async () => {
        clearSelection();

        const title = document.getElementById("title").value.trim();
        const author = document.getElementById("author").value.trim();

        if (!title || !author) {
          resultsEl.innerHTML = `<div class="muted">Please enter both title and author.</div>`;
          return;
        }

        resultsEl.innerHTML = `<div class="muted">Searching…</div>`;

        try {
          const data = await searchGoogleBooks(title, author);
          const items = Array.isArray(data.items) ? data.items : [];
          renderResults(items);
        } catch (err) {
          console.error(err);
          resultsEl.innerHTML = `<div class="muted">Search failed. Open DevTools Console for details.</div>`;
        }
      });

      // Add selected to draft and refresh dashboard
      addBtn.addEventListener("click", async () => {
        if (!selectedBook) return;
        draft = [selectedBook, ...draft];
        saveDraft(draft);
        clearSelection();
        resultsEl.innerHTML = "";
        await refreshDashboard();
        alert("Added (saved locally as Draft).");
      });

      document.getElementById("clear-selection").addEventListener("click", () => {
        clearSelection();
        resultsEl.innerHTML = "";
      });

      // Generate updated books.json output (repo + draft)
      document.getElementById("generate-json").addEventListener("click", async () => {
        outputEl.value = "Generating…";
        try {
          const current = await loadBooksJson();
          const repoBooks = Array.isArray(current.books) ? current.books : [];
          const merged = [...draft, ...repoBooks];
          merged.sort((a, b) => a.release_date.localeCompare(b.release_date));

          const updated = {
            meta: current.meta || { version: 1 },
            books: merged
          };

          outputEl.value = JSON.stringify(updated, null, 2);
        } catch (err) {
          console.error(err);
          outputEl.value = "Failed to generate.";
        }
      });

      document.getElementById("copy-json").addEventListener("click", async () => {
        if (!outputEl.value.trim()) return alert("Nothing to copy yet.");
        try {
          await copyToClipboard(outputEl.value);
          alert("Copied.");
        } catch {
          alert("Could not copy automatically. Select the text and copy manually.");
        }
      });

      document.getElementById("clear-draft").addEventListener("click", async () => {
        if (!confirm("Clear local Draft? This only affects this browser.")) return;
        draft = [];
        saveDraft(draft);
        outputEl.value = "";
        await refreshDashboard();
      });
    })();
  </script>

</body>
</html>
