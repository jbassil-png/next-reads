<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Next Reads</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <style>
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      margin: 24px;
      max-width: 1200px;
      margin-left: auto;
      margin-right: auto;
    }
    h1 { margin: 0 0 6px; }
    p { margin: 0 0 18px; color: #444; }
    .header { margin-bottom: 32px; }
    .section { margin-bottom: 40px; }
    .section h2 {
      margin: 0 0 12px;
      font-size: 18px;
      color: #222;
    }
    .section-description {
      color: #666;
      font-size: 14px;
      margin-bottom: 16px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      background: white;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      overflow: hidden;
    }
    thead {
      background: #f8f8f8;
    }
    th {
      text-align: left;
      padding: 12px 16px;
      font-size: 13px;
      font-weight: 600;
      color: #555;
      border-bottom: 2px solid #e0e0e0;
    }
    td {
      padding: 12px 16px;
      font-size: 14px;
      border-bottom: 1px solid #f0f0f0;
    }
    tbody tr:last-child td {
      border-bottom: none;
    }
    tbody tr:hover {
      background: #fafafa;
    }
    .clickable-row:hover {
      background: #e3f2fd !important;
      transition: background 0.2s;
    }
    .empty-state {
      padding: 48px 24px;
      text-align: center;
      color: #999;
      font-size: 14px;
      background: #fafafa;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
    }
    .status-badge {
      display: inline-block;
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 500;
    }
    .status-not_released { background: #e3f2fd; color: #1565c0; }
    .status-not_available { background: #fff3e0; color: #e65100; }
    .status-available_to_hold { background: #e8f5e9; color: #2e7d32; }
    .status-on_hold { background: #f3e5f5; color: #6a1b9a; }
    .status-available_to_checkout { background: #c8e6c9; color: #1b5e20; }
    .days-label {
      color: #666;
      font-size: 13px;
    }
    .loading {
      text-align: center;
      padding: 48px;
      color: #999;
    }
    .error {
      padding: 16px;
      background: #ffebee;
      color: #c62828;
      border-radius: 8px;
      margin-bottom: 24px;
    }
    .admin-link {
      margin-top: 24px;
      padding: 12px;
      background: #f5f5f5;
      border-radius: 8px;
      text-align: center;
    }
    .admin-link a {
      color: #1976d2;
      text-decoration: none;
      font-weight: 500;
    }
    .admin-link a:hover {
      text-decoration: underline;
    }
    .add-book-section {
      background: white;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      padding: 24px;
      margin-bottom: 32px;
    }
    .add-book-section h2 {
      margin: 0 0 16px;
      font-size: 18px;
      color: #222;
    }
    .form-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
      margin-bottom: 16px;
    }
    .form-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .form-group.full-width {
      grid-column: 1 / -1;
    }
    .form-group label {
      font-size: 13px;
      font-weight: 500;
      color: #555;
    }
    .form-group input,
    .form-group select,
    .form-group textarea {
      padding: 10px 12px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 14px;
      font-family: inherit;
    }
    .form-group textarea {
      resize: vertical;
      min-height: 60px;
    }
    button {
      padding: 10px 20px;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.2s;
    }
    button.primary {
      background: #1976d2;
      color: white;
    }
    button.primary:hover {
      background: #1565c0;
    }
    button.secondary {
      background: #f5f5f5;
      color: #555;
      border: 1px solid #ddd;
      margin-left: 8px;
    }
    button.secondary:hover {
      background: #e0e0e0;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .message {
      padding: 12px 16px;
      border-radius: 6px;
      margin-bottom: 16px;
    }
    .message.success {
      background: #e8f5e9;
      color: #2e7d32;
    }
    .search-results {
      margin-top: 16px;
      display: grid;
      gap: 12px;
    }
    .book-result {
      display: grid;
      grid-template-columns: 80px 1fr auto;
      gap: 16px;
      padding: 12px;
      border: 2px solid #e0e0e0;
      border-radius: 6px;
      background: white;
      transition: all 0.2s;
    }
    .book-result:hover {
      border-color: #1976d2;
      box-shadow: 0 2px 8px rgba(25, 118, 210, 0.1);
    }
    .book-result.selected {
      border-color: #1976d2;
      background: #f0f7ff;
    }
    .book-cover {
      width: 80px;
      height: 120px;
      object-fit: cover;
      border-radius: 4px;
      background: #f5f5f5;
    }
    .book-info {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .book-title {
      font-weight: 600;
      font-size: 15px;
      color: #222;
    }
    .book-author {
      color: #666;
      font-size: 14px;
    }
    .book-meta {
      font-size: 13px;
      color: #888;
    }
    .book-actions {
      display: flex;
      align-items: center;
    }
    .form-step {
      display: none;
    }
    .form-step.active {
      display: block;
    }
    .step-indicator {
      font-size: 13px;
      color: #666;
      margin-bottom: 12px;
    }
    .autocomplete-results {
      position: absolute;
      z-index: 1000;
      background: white;
      border: 1px solid #ddd;
      border-radius: 6px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
      max-height: 300px;
      overflow-y: auto;
      width: 100%;
      margin-top: 4px;
      top: 100%;
    }
    .autocomplete-item {
      padding: 10px 12px;
      cursor: pointer;
      border-bottom: 1px solid #f0f0f0;
    }
    .autocomplete-item:hover {
      background: #f5f5f5;
    }
    .autocomplete-item:last-child {
      border-bottom: none;
    }
    .autocomplete-title {
      font-weight: 500;
      font-size: 14px;
      color: #222;
    }
    .autocomplete-author {
      font-size: 13px;
      color: #666;
      margin-top: 2px;
    }
    .form-group-with-autocomplete {
      position: relative;
    }
  </style>
</head>
<body>

  <div class="header">
    <h1>Next Reads</h1>
    <p>Track upcoming book releases and library availability</p>
  </div>

  <div id="message-container"></div>

  <!-- Add Book Section -->
  <div class="add-book-section">
    <h2>‚ûï Add New Book</h2>

    <!-- Step 1: Search -->
    <div id="step-search" class="form-step active">
      <div class="step-indicator">Start typing a title or author name to search</div>
      <div class="form-grid">
        <div class="form-group form-group-with-autocomplete">
          <label for="search-title">Title</label>
          <input type="text" id="search-title" placeholder="e.g., The Doors of Stone" autocomplete="off">
          <div id="title-autocomplete" class="autocomplete-results" style="display: none;"></div>
        </div>

        <div class="form-group form-group-with-autocomplete">
          <label for="search-author">Author</label>
          <input type="text" id="search-author" placeholder="e.g., Patrick Rothfuss" autocomplete="off">
          <div id="author-autocomplete" class="autocomplete-results" style="display: none;"></div>
        </div>
      </div>
    </div>

    <!-- Step 2: Confirm and Add -->
    <div id="step-confirm" class="form-step">
      <div class="step-indicator">Confirm and add to your list</div>

      <form id="add-book-form">
        <div style="display: grid; grid-template-columns: 100px 1fr; gap: 20px; margin-bottom: 20px;">
          <!-- Cover Image -->
          <div>
            <img id="cover-preview" src="" alt="Book cover" style="width: 100px; height: 150px; object-fit: cover; border-radius: 4px; background: #f5f5f5;">
          </div>

          <!-- Book Details -->
          <div style="display: flex; flex-direction: column; gap: 12px;">
            <div>
              <strong style="font-size: 16px;" id="confirm-title"></strong>
              <div style="color: #666; margin-top: 4px;" id="confirm-author"></div>
            </div>

            <div style="display: grid; grid-template-columns: 1fr; gap: 12px; font-size: 14px;">
              <div>
                <span style="color: #666;">Release Date:</span>
                <span id="confirm-date"></span>
              </div>
            </div>
          </div>
        </div>

        <input type="hidden" id="title">
        <input type="hidden" id="author">
        <input type="hidden" id="release_date">
        <input type="hidden" id="isbn-edit">
        <input type="hidden" id="cover_url">
        <input type="hidden" id="google_books_id">
        <input type="hidden" id="notes">
        <input type="hidden" id="library_status">
        <input type="hidden" id="all_isbns">

        <button type="submit" class="primary">Add to List</button>
        <button type="button" id="back-btn" class="secondary">‚Üê Back to Search</button>
      </form>
    </div>
  </div>

  <!-- Divider -->
  <div style="border-top: 2px solid #e0e0e0; margin: 32px 0;"></div>

  <div id="error-container"></div>
  <div id="app"></div>

  <!-- Supabase JS Client -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <!-- Configuration -->
  <script src="config.js"></script>

  <script>
    // Initialize Supabase clients
    const { createClient } = supabase;
    const supabaseClient = createClient(SUPABASE_CONFIG.url, SUPABASE_CONFIG.anonKey);

    // Admin service role key (TODO: Add password protection before making this public)
    const ADMIN_SERVICE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJtbHhlZ3NvbGZrbGtmemNtbGxwIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc2ODY4MTYwNCwiZXhwIjoyMDg0MjU3NjA0fQ.1Yf5Bj7u8zRhi0asY3_JR6xVFaOU7Df6esh1N6U3Xvo';

    // Admin client for adding/editing books
    const supabaseAdmin = createClient(SUPABASE_CONFIG.url, ADMIN_SERVICE_KEY);

    // Helper: Format date
    function formatDate(dateString) {
      const date = new Date(dateString);
      return date.toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'short',
        day: 'numeric'
      });
    }

    // Helper: Calculate days until/since release
    function getDaysUntil(releaseDate) {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const release = new Date(releaseDate);
      release.setHours(0, 0, 0, 0);
      const diffTime = release - today;
      const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
      return diffDays;
    }

    // Helper: Format status for display
    function formatStatus(status) {
      const statusMap = {
        'not_released': 'Not Released',
        'not_available': 'Not Available',
        'available_to_hold': 'Available to Hold',
        'on_hold': 'On Hold',
        'available_to_checkout': 'Available to Checkout',
        'checked_out': 'Checked Out'
      };
      return statusMap[status] || status;
    }

    // Render "Waiting For" table
    function renderWaitingFor(books) {
      if (books.length === 0) {
        return '<div class="empty-state">No books waiting for library availability</div>';
      }

      return `
        <table>
          <thead>
            <tr>
              <th>Title</th>
              <th>Author</th>
              <th>Released</th>
              <th>Library Status</th>
              <th>Last Checked</th>
              <th style="width: 40px;"></th>
            </tr>
          </thead>
          <tbody>
            ${books.map(book => {
              const daysAgo = Math.abs(getDaysUntil(book.release_date));
              const lastChecked = book.last_checked_at
                ? formatDate(book.last_checked_at)
                : 'Never';

              // Make row clickable if book is available in Overdrive
              const isClickable = book.overdrive_id &&
                                 (book.library_status === 'available_to_hold' ||
                                  book.library_status === 'available_to_checkout');
              const overdriveUrl = book.overdrive_id
                ? `https://sfpl.overdrive.com/media/${book.overdrive_id}`
                : null;
              const rowClass = isClickable ? 'clickable-row' : '';
              const rowClick = isClickable
                ? `onclick="window.open('${overdriveUrl}', '_blank')" style="cursor: pointer;"`
                : '';

              return `
                <tr class="${rowClass}" ${rowClick}>
                  <td><strong>${escapeHtml(book.title)}</strong></td>
                  <td>${escapeHtml(book.author)}</td>
                  <td>
                    ${formatDate(book.release_date)}
                    <div class="days-label">${daysAgo} days ago</div>
                  </td>
                  <td>
                    <span class="status-badge status-${book.library_status}">
                      ${formatStatus(book.library_status)}
                    </span>
                    ${isClickable ? '<span style="margin-left: 8px; color: #1976d2; font-size: 14px;">‚Üó</span>' : ''}
                  </td>
                  <td class="days-label">${lastChecked}</td>
                  <td>
                    <button onclick="event.stopPropagation(); deleteBook('${book.id}', '${escapeHtml(book.title.replace(/'/g, "\\'"))}')"
                            style="background: none; border: none; color: #999; cursor: pointer; font-size: 18px; padding: 4px 8px;"
                            title="Remove book">√ó</button>
                  </td>
                </tr>
              `;
            }).join('')}
          </tbody>
        </table>
      `;
    }

    // Render "Coming Soon" table
    function renderComingSoon(books) {
      if (books.length === 0) {
        return '<div class="empty-state">No upcoming releases</div>';
      }

      return `
        <table>
          <thead>
            <tr>
              <th>Title</th>
              <th>Author</th>
              <th>Release Date</th>
              <th>Days Until Release</th>
              <th>Notes</th>
              <th style="width: 40px;"></th>
            </tr>
          </thead>
          <tbody>
            ${books.map(book => {
              const daysUntil = getDaysUntil(book.release_date);
              const daysLabel = daysUntil === 0 ? 'Today!' :
                                daysUntil === 1 ? 'Tomorrow' :
                                `in ${daysUntil} days`;

              return `
                <tr>
                  <td><strong>${escapeHtml(book.title)}</strong></td>
                  <td>${escapeHtml(book.author)}</td>
                  <td>${formatDate(book.release_date)}</td>
                  <td class="days-label">${daysLabel}</td>
                  <td class="days-label">${book.notes ? escapeHtml(book.notes) : '‚Äî'}</td>
                  <td>
                    <button onclick="deleteBook('${book.id}', '${escapeHtml(book.title.replace(/'/g, "\\'"))}')"
                            style="background: none; border: none; color: #999; cursor: pointer; font-size: 18px; padding: 4px 8px;"
                            title="Remove book">√ó</button>
                  </td>
                </tr>
              `;
            }).join('')}
          </tbody>
        </table>
      `;
    }

    // Escape HTML to prevent XSS
    function escapeHtml(text) {
      if (!text) return '';
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Show error message
    function showError(message) {
      const errorContainer = document.getElementById('error-container');
      errorContainer.innerHTML = `<div class="error">${escapeHtml(message)}</div>`;
    }

    // Show success message
    function showMessage(text, type = 'success') {
      const container = document.getElementById('message-container');
      container.innerHTML = `<div class="message ${type}">${escapeHtml(text)}</div>`;
      setTimeout(() => { container.innerHTML = ''; }, 5000);
    }

    // Normalize title for matching (remove punctuation, articles, extra spaces)
    function normalizeTitle(title) {
      return title
        .toLowerCase()
        .replace(/[^\w\s]/g, '') // Remove punctuation
        .replace(/\s+/g, ' ') // Normalize whitespace
        .replace(/^(a|an|the)\s+/i, '') // Remove leading articles
        .trim();
    }

    // Autocomplete for book titles and authors
    let autocompleteTimeout;

    async function handleTitleAutocomplete(input) {
      const query = input.trim();
      const autocompleteContainer = document.getElementById('title-autocomplete');

      if (query.length < 3) {
        autocompleteContainer.style.display = 'none';
        return;
      }

      // Debounce - wait 500ms after typing stops
      clearTimeout(autocompleteTimeout);
      autocompleteTimeout = setTimeout(async () => {
        try {
          const searchQuery = encodeURIComponent(query);
          const response = await fetch(`https://www.googleapis.com/books/v1/volumes?q=intitle:${searchQuery}&maxResults=20`);
          const data = await response.json();

          if (!data.items || data.items.length === 0) {
            autocompleteContainer.style.display = 'none';
            return;
          }

          // Filter to only show books with ISBNs and with cover images
          const booksWithISBN = data.items.filter(item => {
            const info = item.volumeInfo;
            const hasISBN = info.industryIdentifiers?.some(id =>
              id.type === 'ISBN_13' || id.type === 'ISBN_10'
            );
            const hasCover = info.imageLinks?.thumbnail || info.imageLinks?.smallThumbnail;
            return hasISBN && hasCover;
          });

          if (booksWithISBN.length === 0) {
            autocompleteContainer.style.display = 'none';
            return;
          }

          // Deduplicate by normalized title - keep first occurrence (usually most relevant)
          const seenTitles = new Set();
          const uniqueBooks = [];

          for (const book of booksWithISBN) {
            const normalized = normalizeTitle(book.volumeInfo.title);
            if (!seenTitles.has(normalized)) {
              seenTitles.add(normalized);
              uniqueBooks.push(book);
              if (uniqueBooks.length >= 8) break; // Limit to 8 results
            }
          }

          // Show suggestions
          renderAutocompleteResults(uniqueBooks, autocompleteContainer);
        } catch (error) {
          console.error('Autocomplete error:', error);
          autocompleteContainer.style.display = 'none';
        }
      }, 500);
    }

    async function handleAuthorAutocomplete(input) {
      const query = input.trim();
      const autocompleteContainer = document.getElementById('author-autocomplete');

      if (query.length < 3) {
        autocompleteContainer.style.display = 'none';
        return;
      }

      // Debounce - wait 500ms after typing stops
      clearTimeout(autocompleteTimeout);
      autocompleteTimeout = setTimeout(async () => {
        try {
          const searchQuery = encodeURIComponent(query);
          const response = await fetch(`https://www.googleapis.com/books/v1/volumes?q=inauthor:${searchQuery}&maxResults=20`);
          const data = await response.json();

          if (!data.items || data.items.length === 0) {
            autocompleteContainer.style.display = 'none';
            return;
          }

          // Filter to only show books with ISBNs and with cover images
          const booksWithISBN = data.items.filter(item => {
            const info = item.volumeInfo;
            const hasISBN = info.industryIdentifiers?.some(id =>
              id.type === 'ISBN_13' || id.type === 'ISBN_10'
            );
            const hasCover = info.imageLinks?.thumbnail || info.imageLinks?.smallThumbnail;
            return hasISBN && hasCover;
          });

          if (booksWithISBN.length === 0) {
            autocompleteContainer.style.display = 'none';
            return;
          }

          // Deduplicate by normalized title - keep first occurrence (usually most relevant)
          const seenTitles = new Set();
          const uniqueBooks = [];

          for (const book of booksWithISBN) {
            const normalized = normalizeTitle(book.volumeInfo.title);
            if (!seenTitles.has(normalized)) {
              seenTitles.add(normalized);
              uniqueBooks.push(book);
              if (uniqueBooks.length >= 8) break; // Limit to 8 results
            }
          }

          // Show suggestions
          renderAutocompleteResults(uniqueBooks, autocompleteContainer);
        } catch (error) {
          console.error('Autocomplete error:', error);
          autocompleteContainer.style.display = 'none';
        }
      }, 500);
    }

    // Render autocomplete suggestions
    function renderAutocompleteResults(items, container) {
      // Clear previous items and initialize
      window.autocompleteItems = [];

      // Store items and render
      container.innerHTML = items.map((item, index) => {
        const info = item.volumeInfo;
        const authors = info.authors ? info.authors.join(', ') : 'Unknown Author';

        // Store the item for onclick access
        window.autocompleteItems[index] = item;

        return `
          <div class="autocomplete-item" onclick='selectBookFromAutocomplete(${index})'>
            <div class="autocomplete-title">${escapeHtml(info.title)}</div>
            <div class="autocomplete-author">${escapeHtml(authors)}</div>
          </div>
        `;
      }).join('');

      container.style.display = 'block';
    }

    // Select book from autocomplete and go directly to confirm step
    window.selectBookFromAutocomplete = async function(index) {
      const bookData = window.autocompleteItems[index];
      if (!bookData) {
        console.error('No book data found for index', index);
        return;
      }
      const info = bookData.volumeInfo;
      const authors = info.authors ? info.authors.join(', ') : '';
      const publishedDate = info.publishedDate || '';
      const isbn = info.industryIdentifiers?.find(id => id.type === 'ISBN_13')?.identifier ||
                  info.industryIdentifiers?.find(id => id.type === 'ISBN_10')?.identifier || '';
      const coverUrl = info.imageLinks?.thumbnail?.replace('http:', 'https:') ||
                      info.imageLinks?.smallThumbnail?.replace('http:', 'https:') || '';

      // Fetch all editions of this book to collect all ISBNs
      console.log('Fetching all editions for:', info.title);
      const allIsbns = new Set();

      // Add ISBNs from the selected book
      if (info.industryIdentifiers) {
        info.industryIdentifiers.forEach(id => {
          if (id.type === 'ISBN_13' || id.type === 'ISBN_10') {
            allIsbns.add(id.identifier);
          }
        });
      }

      try {
        // Search for all editions by title and author
        const searchQuery = encodeURIComponent(`intitle:"${info.title}" ${authors ? 'inauthor:' + authors.split(',')[0] : ''}`);
        const response = await fetch(`https://www.googleapis.com/books/v1/volumes?q=${searchQuery}&maxResults=40`);
        const data = await response.json();

        if (data.items) {
          const normalizedTargetTitle = normalizeTitle(info.title);

          // Filter to books with matching normalized title
          const matchingEditions = data.items.filter(item => {
            const editionTitle = item.volumeInfo?.title || '';
            return normalizeTitle(editionTitle) === normalizedTargetTitle;
          });

          console.log(`Found ${matchingEditions.length} matching editions`);

          // Collect all ISBNs from all editions
          matchingEditions.forEach(edition => {
            const identifiers = edition.volumeInfo?.industryIdentifiers || [];
            identifiers.forEach(id => {
              if (id.type === 'ISBN_13' || id.type === 'ISBN_10') {
                allIsbns.add(id.identifier);
              }
            });
          });
        }
      } catch (error) {
        console.error('Error fetching all editions:', error);
      }

      const allIsbnsArray = Array.from(allIsbns);
      console.log(`Collected ${allIsbnsArray.length} unique ISBNs:`, allIsbnsArray);

      // Normalize date to YYYY-MM-DD
      let normalizedDate = '';
      if (publishedDate) {
        if (/^\d{4}$/.test(publishedDate)) {
          normalizedDate = `${publishedDate}-12-31`;
        } else if (/^\d{4}-\d{2}$/.test(publishedDate)) {
          normalizedDate = `${publishedDate}-01`;
        } else {
          normalizedDate = publishedDate;
        }
      }

      // Fill hidden form fields
      document.getElementById('title').value = info.title || '';
      document.getElementById('author').value = authors;
      document.getElementById('release_date').value = normalizedDate;
      document.getElementById('isbn-edit').value = isbn;
      document.getElementById('cover_url').value = coverUrl;
      document.getElementById('google_books_id').value = bookData.id;
      document.getElementById('notes').value = ''; // Always empty now
      document.getElementById('all_isbns').value = JSON.stringify(allIsbnsArray);

      // Update display fields
      document.getElementById('confirm-title').textContent = info.title || '';
      document.getElementById('confirm-author').textContent = authors;
      document.getElementById('confirm-date').textContent = publishedDate || 'Unknown';

      // Update cover preview
      const coverPreview = document.getElementById('cover-preview');
      if (coverUrl) {
        coverPreview.src = coverUrl;
        coverPreview.style.display = 'block';
      } else {
        coverPreview.src = '';
        coverPreview.style.display = 'none';
      }

      // Set default library status based on release date
      const today = new Date();
      const releaseDate = new Date(normalizedDate);
      if (releaseDate > today) {
        document.getElementById('library_status').value = 'not_released';
      } else {
        document.getElementById('library_status').value = 'not_available';
      }

      // Hide autocomplete
      document.getElementById('title-autocomplete').style.display = 'none';
      document.getElementById('author-autocomplete').style.display = 'none';

      // Switch to step 2
      document.getElementById('step-search').classList.remove('active');
      document.getElementById('step-confirm').classList.add('active');
    };

    // Hide autocomplete when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.form-group-with-autocomplete')) {
        document.getElementById('title-autocomplete').style.display = 'none';
        document.getElementById('author-autocomplete').style.display = 'none';
      }
    });

    // Search Google Books
    async function searchGoogleBooks() {
      const title = document.getElementById('search-title').value.trim();
      const author = document.getElementById('search-author').value.trim();

      if (!title || !author) {
        showMessage('Please enter both title and author', 'error');
        return;
      }

      const resultsContainer = document.getElementById('search-results');
      const searchBtn = document.getElementById('search-btn');

      // Show loading state
      resultsContainer.innerHTML = '<div class="loading" style="padding: 24px;">üîç Searching Google Books...</div>';
      searchBtn.disabled = true;
      searchBtn.textContent = 'Searching...';

      try {
        // Build search query - try title and author together
        const query = encodeURIComponent(`intitle:${title} inauthor:${author}`);
        console.log('Searching Google Books:', query);

        const response = await fetch(`https://www.googleapis.com/books/v1/volumes?q=${query}&maxResults=10`);

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const data = await response.json();
        console.log('Google Books response:', data);

        if (!data.items || data.items.length === 0) {
          resultsContainer.innerHTML = `
            <div class="empty-state">
              No books found for "${title}" by "${author}".<br>
              Try different search terms or check spelling.
            </div>
          `;
          return;
        }

        // Filter to only show books with ISBNs (needed for Overdrive matching)
        const booksWithISBN = data.items.filter(item => {
          const info = item.volumeInfo;
          return info.industryIdentifiers?.some(id =>
            id.type === 'ISBN_13' || id.type === 'ISBN_10'
          );
        });

        if (booksWithISBN.length === 0) {
          resultsContainer.innerHTML = `
            <div class="empty-state">
              No books with ISBNs found for "${title}" by "${author}".<br>
              Try different search terms.
            </div>
          `;
          return;
        }

        // Check Overdrive to see which results are available at SFPL
        let overdriveTitles = new Set();
        try {
          const overdriveQuery = encodeURIComponent(title);
          const overdriveResponse = await fetch(`https://thunder.api.overdrive.com/v2/libraries/sfpl/media?query=${overdriveQuery}`);
          if (overdriveResponse.ok) {
            const overdriveData = await overdriveResponse.json();
            if (overdriveData.items) {
              // Store all Overdrive titles (lowercase for matching)
              overdriveData.items.forEach(item => {
                overdriveTitles.add(item.title.toLowerCase());
              });
            }
          }
        } catch (error) {
          console.log('Could not check Overdrive:', error);
        }

        // Sort books with Overdrive matches first
        const sortedBooks = booksWithISBN.sort((a, b) => {
          const aInOverdrive = overdriveTitles.has(a.volumeInfo.title.toLowerCase());
          const bInOverdrive = overdriveTitles.has(b.volumeInfo.title.toLowerCase());
          if (aInOverdrive && !bInOverdrive) return -1;
          if (!aInOverdrive && bInOverdrive) return 1;
          return 0;
        });

        // Store search results globally for selection
        window.searchResults = sortedBooks;

        // Render results
        resultsContainer.innerHTML = sortedBooks.map((item, index) => {
          const info = item.volumeInfo;
          const authors = info.authors ? info.authors.join(', ') : 'Unknown Author';
          const publishedDate = info.publishedDate || 'Unknown';

          // Show ALL ISBNs
          const allISBNs = info.industryIdentifiers?.map(id => `${id.identifier} (${id.type})`).join(', ') || 'No ISBN';

          const thumbnail = info.imageLinks?.thumbnail || info.imageLinks?.smallThumbnail || '';
          const inOverdrive = overdriveTitles.has(info.title.toLowerCase());

          return `
            <div class="book-result" data-book-index="${index}">
              ${thumbnail ? `<img src="${thumbnail}" alt="Cover" class="book-cover">` : '<div class="book-cover"></div>'}
              <div class="book-info">
                <div class="book-title">
                  ${escapeHtml(info.title)}
                  ${inOverdrive ? '<span style="margin-left: 8px; padding: 2px 8px; background: #FF9800; color: white; border-radius: 4px; font-size: 12px; font-weight: 600;">IN OVERDRIVE</span>' : ''}
                </div>
                <div class="book-author">${escapeHtml(authors)}</div>
                <div class="book-meta">
                  Published: ${escapeHtml(publishedDate)}<br>
                  ISBNs: ${escapeHtml(allISBNs)}
                </div>
              </div>
              <div class="book-actions">
                <button type="button" class="primary" onclick="selectBook(${index})">
                  Select This Book
                </button>
              </div>
            </div>
          `;
        }).join('');

      } catch (error) {
        console.error('Error searching books:', error);
        resultsContainer.innerHTML = `
          <div class="error">
            Failed to search Google Books: ${escapeHtml(error.message)}<br>
            Please check your internet connection and try again.
          </div>
        `;
      } finally {
        // Reset button state
        searchBtn.disabled = false;
        searchBtn.textContent = 'üîç Search Google Books';
      }
    }

    // Select a book from search results
    window.selectBook = function(index) {
      const bookData = window.searchResults[index];
      const info = bookData.volumeInfo;
      const authors = info.authors ? info.authors.join(', ') : '';
      const publishedDate = info.publishedDate || '';
      const isbn = info.industryIdentifiers?.find(id => id.type === 'ISBN_13')?.identifier ||
                  info.industryIdentifiers?.find(id => id.type === 'ISBN_10')?.identifier || '';
      const coverUrl = info.imageLinks?.thumbnail?.replace('http:', 'https:') ||
                      info.imageLinks?.smallThumbnail?.replace('http:', 'https:') || '';

      // Normalize date to YYYY-MM-DD
      let normalizedDate = '';
      if (publishedDate) {
        if (/^\d{4}$/.test(publishedDate)) {
          // Year only -> use Dec 31
          normalizedDate = `${publishedDate}-12-31`;
        } else if (/^\d{4}-\d{2}$/.test(publishedDate)) {
          // Year-Month -> use last day of month
          normalizedDate = `${publishedDate}-01`;
        } else {
          normalizedDate = publishedDate;
        }
      }

      // Fill form
      document.getElementById('title').value = info.title || '';
      document.getElementById('author').value = authors;
      document.getElementById('release_date').value = normalizedDate;
      document.getElementById('isbn').value = isbn;
      document.getElementById('cover_url').value = coverUrl;
      document.getElementById('google_books_id').value = bookData.id;

      // Set default library status based on release date
      const today = new Date();
      const releaseDate = new Date(normalizedDate);
      if (releaseDate > today) {
        document.getElementById('library_status').value = 'not_released';
      } else {
        document.getElementById('library_status').value = 'not_available';
      }

      // Switch to step 2
      document.getElementById('step-search').classList.remove('active');
      document.getElementById('step-confirm').classList.add('active');
    };

    // Go back to search
    function goBackToSearch() {
      // Clear search fields
      document.getElementById('search-title').value = '';
      document.getElementById('search-author').value = '';
      document.getElementById('title-autocomplete').style.display = 'none';
      document.getElementById('author-autocomplete').style.display = 'none';

      // Switch back to search step
      document.getElementById('step-confirm').classList.remove('active');
      document.getElementById('step-search').classList.add('active');
    }

    // Add book form handler
    async function handleAddBook(e) {
      e.preventDefault();

      // Parse all_isbns from JSON
      let allIsbnsArray = [];
      try {
        const allIsbnsValue = document.getElementById('all_isbns').value;
        if (allIsbnsValue) {
          allIsbnsArray = JSON.parse(allIsbnsValue);
        }
      } catch (error) {
        console.error('Error parsing all_isbns:', error);
      }

      const formData = {
        title: document.getElementById('title').value.trim(),
        author: document.getElementById('author').value.trim(),
        release_date: document.getElementById('release_date').value,
        library_status: document.getElementById('library_status').value,
        isbn: document.getElementById('isbn-edit').value.trim() || null,
        all_isbns: allIsbnsArray.length > 0 ? allIsbnsArray : null,
        cover_url: document.getElementById('cover_url').value.trim() || null,
        google_books_id: document.getElementById('google_books_id').value.trim() || null,
        notes: null
      };

      try {
        const { data, error } = await supabaseAdmin
          .from('books')
          .insert([formData])
          .select();

        if (error) throw error;

        const addedBook = data[0];
        showMessage(`‚úì Added "${formData.title}" successfully!`, 'success');

        // Check library status if book is released
        if (formData.library_status !== 'not_released') {
          showMessage(`Checking library availability...`, 'info');
          const result = await checkSingleBook(addedBook);

          if (result) {
            // Update the book with library status and overdrive_id
            await supabaseAdmin
              .from('books')
              .update({
                library_status: result.status,
                overdrive_id: result.overdrive_id,
                last_checked_at: new Date().toISOString()
              })
              .eq('id', addedBook.id);

            showMessage(`‚úì Library status updated: ${formatStatus(result.status)}`, 'success');
          }
        }

        // Reset form and go back to search
        document.getElementById('add-book-form').reset();
        goBackToSearch();

        render(); // Refresh the book list
      } catch (error) {
        console.error('Error adding book:', error);
        showMessage(`Error: ${error.message}`, 'error');
      }
    }

    // Delete book handler
    window.deleteBook = async function(bookId, bookTitle) {
      if (!confirm(`Remove "${bookTitle}" from your list?`)) {
        return;
      }

      try {
        const { error } = await supabaseAdmin
          .from('books')
          .delete()
          .eq('id', bookId);

        if (error) throw error;

        showMessage(`‚úì Removed "${bookTitle}" from list`, 'success');
        render(); // Refresh the book list
      } catch (error) {
        console.error('Error deleting book:', error);
        showMessage(`Error: ${error.message}`, 'error');
      }
    };

    // Check single book's library status via Overdrive
    async function checkSingleBook(book) {
      try {
        // Search by title to find book in Overdrive
        const query = encodeURIComponent(book.title);
        const searchUrl = `https://thunder.api.overdrive.com/v2/libraries/sfpl/media?query=${query}`;
        const searchResponse = await fetch(searchUrl);

        if (!searchResponse.ok) {
          console.error(`Overdrive search failed for ${book.title}`);
          return null;
        }

        const searchData = await searchResponse.json();

        if (!searchData.items || searchData.items.length === 0) {
          // Not in Overdrive catalog at all
          return { status: 'not_available', overdrive_id: null };
        }

        // Find best match using multiple strategies:
        // 1. If we have all_isbns, try to match by ISBN
        // 2. Fall back to normalized title matching
        // Only store overdrive_id if we have a confident match
        let overdriveBook = null;
        let matchFound = false;

        if (book.all_isbns && book.all_isbns.length > 0) {
          // Try to find a match by ISBN
          const isbnMatch = searchData.items.find(item => {
            const overdriveIsbns = item.formats?.map(f => f.isbn).filter(Boolean) || [];
            return book.all_isbns.some(ourIsbn =>
              overdriveIsbns.some(odIsbn => odIsbn === ourIsbn)
            );
          });

          if (isbnMatch) {
            console.log(`ISBN match found for ${book.title}`);
            overdriveBook = isbnMatch;
            matchFound = true;
          }
        }

        // If no ISBN match, try normalized title matching
        if (!matchFound) {
          const normalizedBookTitle = normalizeTitle(book.title);
          const titleMatch = searchData.items.find(item =>
            normalizeTitle(item.title) === normalizedBookTitle
          );
          if (titleMatch) {
            console.log(`Title match found for ${book.title}`);
            overdriveBook = titleMatch;
            matchFound = true;
          }
        }

        // If no confident match found, don't store overdrive_id
        if (!matchFound) {
          console.log(`No confident match for ${book.title} in Overdrive`);
          return { status: 'not_available', overdrive_id: null };
        }

        const isAvailable = overdriveBook.isAvailable === true;
        const availableCopies = overdriveBook.availableCopies || 0;
        const isHoldable = overdriveBook.isHoldable === true;
        const overdriveId = overdriveBook.id || null;

        // Determine library status
        let status;
        if (isAvailable && availableCopies > 0) {
          status = 'available_to_checkout';
        } else if (isHoldable) {
          status = 'available_to_hold';
        } else {
          status = 'not_available';
        }

        return { status, overdrive_id: overdriveId };
      } catch (error) {
        console.error(`Error checking ${book.title}:`, error);
        return null;
      }
    }

    // Check all books' library status via Edge Function
    window.checkAllBooks = async function() {
      const button = event.target;
      const originalText = button.textContent;
      button.disabled = true;
      button.textContent = 'Checking...';

      try {
        const response = await fetch(
          'https://rmlxegsolfklkfzcmllp.supabase.co/functions/v1/check-overdrive',
          {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${SUPABASE_CONFIG.anonKey}`
            }
          }
        );

        if (!response.ok) {
          throw new Error('Failed to check library status');
        }

        const result = await response.json();
        showMessage(`‚úì Checked ${result.checked} books for library availability`, 'success');
        render(); // Refresh to show updated statuses
      } catch (error) {
        console.error('Error checking all books:', error);
        showMessage(`Error: ${error.message}`, 'error');
      } finally {
        button.disabled = false;
        button.textContent = originalText;
      }
    };

    // Main render function
    async function render() {
      const app = document.getElementById('app');
      app.innerHTML = '<div class="loading">Loading books...</div>';

      try {
        // Fetch all books (excluding checked_out)
        const { data: books, error } = await supabaseClient
          .from('books')
          .select('*')
          .neq('library_status', 'checked_out')
          .order('release_date', { ascending: true });

        if (error) throw error;

        // Split into waiting and coming soon
        const today = new Date();
        today.setHours(0, 0, 0, 0);

        const waitingFor = books.filter(book => {
          const releaseDate = new Date(book.release_date);
          releaseDate.setHours(0, 0, 0, 0);
          return releaseDate <= today;
        }).sort((a, b) => b.release_date.localeCompare(a.release_date)); // Most recent first

        const comingSoon = books.filter(book => {
          const releaseDate = new Date(book.release_date);
          releaseDate.setHours(0, 0, 0, 0);
          return releaseDate > today;
        }).sort((a, b) => a.release_date.localeCompare(b.release_date)); // Soonest first

        // Render dashboard
        app.innerHTML = `
          <div class="section">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
              <h2 style="margin: 0;">Waiting For (${waitingFor.length})</h2>
              <button onclick="checkAllBooks()"
                      style="padding: 6px 12px; font-size: 13px; background: #1976d2; color: white; border: none; border-radius: 4px; cursor: pointer;">
                Check Library Status
              </button>
            </div>
            <div class="section-description">
              Released books not yet available or on hold at the library
            </div>
            ${renderWaitingFor(waitingFor)}
          </div>

          <div class="section">
            <h2>Coming Soon (${comingSoon.length})</h2>
            <div class="section-description">
              Books not yet released, sorted by release date
            </div>
            ${renderComingSoon(comingSoon)}
          </div>
        `;

      } catch (error) {
        console.error('Error loading books:', error);
        showError(`Failed to load books: ${error.message}`);
        app.innerHTML = '';
      }
    }

    // Load on page load
    document.addEventListener('DOMContentLoaded', () => {
      // Attach event handlers (no password protection until final submit)
      document.getElementById('add-book-form').addEventListener('submit', handleAddBook);
      document.getElementById('back-btn').addEventListener('click', goBackToSearch);

      // Autocomplete on title input
      document.getElementById('search-title').addEventListener('input', (e) => {
        handleTitleAutocomplete(e.target.value);
      });

      // Autocomplete on author input
      document.getElementById('search-author').addEventListener('input', (e) => {
        handleAuthorAutocomplete(e.target.value);
      });

      // Load books
      render();
    });
  </script>

</body>
</html>
